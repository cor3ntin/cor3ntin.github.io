<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>GitHub Statistics</title>

  <link rel="alternate icon" class="js-site-favicon" type="image/png" href="https://github.githubassets.com/favicons/favicon.png">
  <script>
    // Read token from URL query parameter if present
    params = new URLSearchParams(window.location.search);

    function updateUrl(params) {
      url = new URL(window.location)
      url.search = params
      console.log(url)
      history.pushState({}, "", decodeURIComponent(url));
    }

    let GITHUB_TOKEN = params.get('token') || localStorage.getItem('gh_token');
    if (!GITHUB_TOKEN) {
      GITHUB_TOKEN = prompt('Please enter your GitHub Personal Access Token with repo scope:');
      localStorage.setItem('gh_token', GITHUB_TOKEN);
      params = new URLSearchParams(window.location.search);
      params.set(token, GITHUB_TOKEN)
      updateUrl(params)
    }
    // Function to clear stored token
    function clearToken() {
      localStorage.removeItem('gh_token');
      alert('GitHub token cleared. The page will reload so you can re-enter your token.');
      location.reload();
    }

    async function fetchGraphQL(query) {
      const res = await fetch('https://api.github.com/graphql', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `bearer ${GITHUB_TOKEN}` },
        body: JSON.stringify({ query })
      });
      const { data, errors } = await res.json();
      if (errors) { console.error('GraphQL errors:', errors); throw new Error('GraphQL query failed'); }
      return data;
    }

    function populateSelect(id, items, defaults = []) {
      const sel = document.getElementById(id); sel.innerHTML = '';
      items.forEach(item => {
        const opt = document.createElement('option'); opt.value = item; opt.textContent = item;
        if (defaults.includes(item)) opt.selected = true;
        sel.appendChild(opt);
      });
    }

    async function fetchPaginatedResults(type, sinceDate, untilDate, labelQuery) {
      const bar = document.getElementById('progress-bar'); let page = 0; const all = []; let hasNext = true, cursor = null;
      while (hasNext) {
        if (bar) bar.style.width = `${Math.min(++page * 10, 100)}%`;
        const pagination = cursor ? `, after: "${cursor}"` : '';
        const query = `
          query {
            results: search(
              query: "repo:llvm/llvm-project ${labelQuery} updated:>=${sinceDate} updated:<=${untilDate} is:${type}",
              type: ISSUE_ADVANCED, first: 100${pagination}
            ) { pageInfo { hasNextPage endCursor } nodes {
                ... on PullRequest { number title url createdAt state author{login} labels(first:100){nodes{name}} reviews(first:100){nodes{author{login}submittedAt}} }
                ... on Issue { number title url closedAt labels(first:100){nodes{name}} timelineItems(itemTypes:[CLOSED_EVENT],first:100){nodes{...on ClosedEvent{actor{login}}}} closedByPullRequestsReferences(first:100){nodes{number url author{login}}} }
            }}
          }`;
        const data = await fetchGraphQL(query).then(d => d.results);
        all.push(...data.nodes);
        hasNext = data.pageInfo.hasNextPage; cursor = data.pageInfo.endCursor;
      }
      return all;
    }

    function stringToColor(str) {
      const p = ['#6f42c1', '#d73a49', '#28a745', '#005cc5', '#e36209', '#0366d6', '#b60205', '#1d76db', '#0e8a16', '#f66a0a'];
      let h = 0; for (let c of str) h = c.charCodeAt(0) + ((h << 5) - h);
      return { bg: p[Math.abs(h) % p.length], text: '#fff' };
    }

    function renderTable(id, data, cols) {
      const t = document.getElementById(id);
      // Build header row, mapping viaPR to "PR"
      const headerHtml = cols.map(c => {
        const label = c === 'viaPR' ? 'PR' : c.charAt(0).toUpperCase() + c.slice(1);
        return `<th>${label}</th>`;
      }).join('');
      t.innerHTML = `<tr>${headerHtml}</tr>`;
      data.forEach(r => {
        const tr = document.createElement('tr');
        cols.forEach(c => {
          const td = document.createElement('td');
          if (c === 'viaPR') {
            td.innerHTML = r.viaPR ? `<a href="${r.prUrl}" target="_blank"><span style="font-weight:bold;color:#6f42c1">[PR]</span></a>` : '';
          } else if (c === 'number') {
            td.innerHTML = `<a href="${r.url}" target="_blank">#${r.number}</a>`;
          } else {
            td.innerHTML = r[c];
          }
          tr.appendChild(td);
        });
        t.appendChild(tr);
      });
    }

    function updateUrlParams(users, tags, since, until) {
      params = new URLSearchParams(window.location.search);
      params.set('usernames', users.join(','))
      params.set('tags', tags.join(','))
      params.set('since', since)
      params.set('until', until)
      updateUrl(params)
    }

    async function loadActivity() {
      document.getElementById('progress').style.display = 'block'

      const users = document.getElementById('usernames').value.split(',').map(s => s.trim()).filter(Boolean);
      const tags = Array.from(document.getElementById('tag-filters').selectedOptions).map(o => o.value);
      const since = document.getElementById('since-date').value;
      const until = document.getElementById('until-date').value;
      updateUrlParams(users, tags, since, until)

      const lblQ = tags.length ? `(${tags.map(t => `label:${t}`).join(' OR ')})` : '';

      ['opened-prs', 'reviewed-prs', 'closed-issues'].forEach(id => document.getElementById(id).innerHTML = '');
      const prs = await fetchPaginatedResults('pr', since, until, lblQ);
      const iss = await fetchPaginatedResults('issue', since, until, lblQ);

      const opened = [], reviewed = [], closed = []; const seen = new Set();
      prs.forEach(pr => {
        const labels = pr.labels.nodes.map(n => n.name);
        const lblHTML = labels.map(l => { const c = stringToColor(l); return `<span class='label' style='background:${c.bg};color:${c.text}'>${l}</span>`; }).join(' ');
        if(pr.author == null)
          return
        if (users.includes(pr.author.login) && pr.state !== 'CLOSED') opened.push({ number: pr.number, title: pr.title, url: pr.url, author: pr.author.login, status: pr.state, date: new Date(pr.createdAt).toISOString().slice(0, 10), labels: lblHTML });
        pr.reviews.nodes.forEach(rv => { const key = `${rv.author.login}-${pr.number}`; if (users.includes(rv.author.login) && new Date(rv.submittedAt) >= new Date(since) && !seen.has(key)) { reviewed.push({ number: pr.number, title: pr.title, url: pr.url, reviewer: rv.author.login, date: rv.submittedAt.slice(0, 10), labels: lblHTML }); seen.add(key); } });
      });
      iss.forEach(issue => {
        const labelsArr = issue.labels.nodes.map(n => n.name);
        const lblHTML = labelsArr.map(l => {
          const c = stringToColor(l);
          return `<span class='label' style='background:${c.bg};color:${c.text}'>${l}</span>`;
        }).join(' ');
        const refs = issue.closedByPullRequestsReferences.nodes || [];
        const ref = refs[refs.length - 1];
        const prUrl = ref?.url;
        const ce = issue.timelineItems.nodes.find(e => e.actor && e.actor.login);
        let actor = null;
        let via = false;
        if (ref && users.includes(ref.author.login)) { actor = ref.author.login; via = true; }
        else if (ce && users.includes(ce.actor.login)) { actor = ce.actor.login; }
        if (actor && new Date(issue.closedAt) >= new Date(since)) {
          closed.push({
            number: issue.number,
            title: issue.title,
            url: issue.url,
            closer: actor,
            date: new Date(issue.closedAt).toISOString().slice(0, 10),
            labels: lblHTML,
            viaPR: via,
            prUrl: prUrl
          });
        }
      });
      closed.sort((a, b) => b.viaPR - a.viaPR);

      renderTable('opened-prs', opened, ['number', 'title', 'author', 'status', 'date', 'labels']);
      renderTable('reviewed-prs', reviewed, ['number', 'title', 'reviewer', 'date', 'labels']);
      renderTable('closed-issues', closed, ['number', 'title', 'viaPR', 'closer', 'date', 'labels']);

      document.getElementById('progress').style.display = 'none'
    }
    // Populate labels and initialize on page load
    window.onload = async () => {
      try {
        // Override usernames from URL query parameter if provided
        userParam = params.get('usernames');
        if (userParam)
          document.getElementById('usernames').value = userParam;


        const labels = [
          "clang", "clang:frontend", "clang:driver", "clang:codegen",
          "clang:modules", "clang:diagnostics",
          "c", "c99", "c11", "c2y", "c23", "c",
          "c++", "c++11", "c++14", "c++17", "c++20", "c++23", "c++26",
          "clang:headers", "clang-cl", "clang:PCH",
          "clang:bytecode", "extension:clang", "clang:to-be-triaged",
          "clang:memory-safety", "clang:bounds-safety",
          "extension:microsoft", "extension:gnu", "compiler-rt",
          "documentation", "libc++", "libc++abi"
        ]

        const userLabels = params.get('tags');
        if(userLabels)
          selectedLabels = userLabels.split(",")
        else
          selectedLabels = ['clang', 'clang:frontend', "clang:driver",
                            "clang:codegen", "clang:modules",
                            "clang:diagnostics"]

        populateSelect('tag-filters', labels, selectedLabels);

        dateSince = params.get('since');
        dateUntil = params.get('until');
        if(!dateSince)
          dateSince = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10);
        if(!dateUntil)
          dateUntil = new Date().toISOString().slice(0, 10);
        document.getElementById('since-date').value = dateSince;
        document.getElementById('until-date').value = dateUntil;

        await loadActivity();
      } catch (err) {
        console.error('Initialization failed', err);
      }
    };
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }

    .controls {
      margin-bottom: 16px;
    }

    input,
    select {
      margin-right: 8px;
    }

    .label {
      display: inline-block;
      padding: 2px 6px;
      margin: 2px;
      font-size: 10px;
      border-radius: 2em;
      font-weight: 500;
    }

    #progress {
      display: none;
      width: 100%;
    }

    #progress-container {
      width: 100%;
      background: #eee;
      height: 8px;
      margin: 12px 0;
      border-radius: 4px;
    }

    #progress-bar {
      height: 8px;
      width: 0%;
      background: #28a745;
      transition: width .3s;
      border-radius: 4px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 8px;
      vertical-align: top;
    }

    th {
      background: #f2f2f2;
    }

    tr:hover {
      background: #f5f5f5;
    }

    a {
      color: #0366d6;
      text-decoration: none;
    }

    .controls {
      font-size: x-large;
    }
    input, select {
      font-size: x-large;
    }
  </style>
</head>

<body>
  <h1>GitHub Statistics</h1>
  <div class="controls">
    <label for="usernames">Usernames:</label>
    <input type="text" id="usernames" value="cor3ntin" placeholder="user1,user2" style="width:400px;">
    <label for="tag-filters">Labels:</label>
    <select id="tag-filters" multiple size="8" style="width:500px;" multiselect-search="true">
    </select>
    <br><br>
    <label for="since-date">Since:</label>
    <input type="date" id="since-date">
    <label for="until-date">Until:</label>
    <input type="date" id="until-date">
    <button onclick="loadActivity()">Reload</button>
    <button onclick="clearToken()" style="margin-left:8px;">Clear Token</button>
  </div>
  <div id="progress">
    <span> Loading the data from Github can take a while... </span>
    <div id="progress-container">
      <div id="progress-bar"></div>
    </div>
  </div>

  <h2>PRs Opened</h2>
  <table id="opened-prs"></table>
  <h2>Issues Closed</h2>
  <table id="closed-issues"></table>
  <h2>PRs Reviewed</h2>
  <table id="reviewed-prs"></table>
</body>

<!--https://github.com/admirhodzic/multiselect-dropdown-->
<script>
var style = document.createElement('style');
style.setAttribute("id","multiselect_dropdown_styles");
style.innerHTML = `
.multiselect-dropdown{
  display: inline-block;
  padding: 2px 5px 0px 5px;
  border-radius: 4px;
  border: solid 1px #ced4da;
  background-color: white;
  position: relative;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right .75rem center;
  background-size: 16px 12px;
}
.multiselect-dropdown span.optext, .multiselect-dropdown span.placeholder{
  margin-right:0.5em;
  margin-bottom:2px;
  padding:1px 0;
  border-radius: 4px;
  display:inline-block;
}
.multiselect-dropdown span.optext{
  background-color:lightgray;
  padding:1px 0.75em;
}
.multiselect-dropdown span.optext .optdel {
  float: right;
  margin: 0 -6px 1px 5px;
  font-size: 0.7em;
  margin-top: 2px;
  cursor: pointer;
  color: #666;
}
.multiselect-dropdown span.optext .optdel:hover { color: #c66;}
.multiselect-dropdown span.placeholder{
  color:#ced4da;
}
.multiselect-dropdown-list-wrapper{
  box-shadow: gray 0 3px 8px;
  z-index: 100;
  padding:2px;
  border-radius: 4px;
  border: solid 1px #ced4da;
  display: none;
  margin: -1px;
  position: absolute;
  top:0;
  left: 0;
  right: 0;
  background: white;
}
.multiselect-dropdown-list-wrapper .multiselect-dropdown-search{
  margin-bottom:5px;
}
.multiselect-dropdown-list{
  padding:2px;
  height: 15rem;
  overflow-y:auto;
  overflow-x: hidden;
}
.multiselect-dropdown-list::-webkit-scrollbar {
  width: 6px;
}
.multiselect-dropdown-list::-webkit-scrollbar-thumb {
  background-color: #bec4ca;
  border-radius:3px;
}

.multiselect-dropdown-list div{
  padding: 5px;
}
.multiselect-dropdown-list input{
  height: 1.15em;
  width: 1.15em;
  margin-right: 0.35em;
}
.multiselect-dropdown-list div.checked{
}
.multiselect-dropdown-list div:hover{
  background-color: #ced4da;
}
.multiselect-dropdown span.maxselected {width:100%;}
.multiselect-dropdown-all-selector {border-bottom:solid 1px #999;}
`;
document.head.appendChild(style);

function MultiselectDropdown(options){
  var config={
    search:true,
    height:'15rem',
    placeholder:'select',
    txtSelected:'selected',
    txtAll:'All',
    txtRemove: 'Remove',
    txtSearch:'search',
    ...options
  };
  function newEl(tag,attrs){
    var e=document.createElement(tag);
    if(attrs!==undefined) Object.keys(attrs).forEach(k=>{
      if(k==='class') { Array.isArray(attrs[k]) ? attrs[k].forEach(o=>o!==''?e.classList.add(o):0) : (attrs[k]!==''?e.classList.add(attrs[k]):0)}
      else if(k==='style'){
        Object.keys(attrs[k]).forEach(ks=>{
          e.style[ks]=attrs[k][ks];
        });
       }
      else if(k==='text'){attrs[k]===''?e.innerHTML='&nbsp;':e.innerText=attrs[k]}
      else e[k]=attrs[k];
    });
    return e;
  }


  document.querySelectorAll("select[multiple]").forEach((el,k)=>{

    var div=newEl('div',{class:'multiselect-dropdown',style:{width:config.style?.width??el.clientWidth+'px',padding:config.style?.padding??''}});
    el.style.display='none';
    el.parentNode.insertBefore(div,el.nextSibling);
    var listWrap=newEl('div',{class:'multiselect-dropdown-list-wrapper'});
    var list=newEl('div',{class:'multiselect-dropdown-list',style:{height:config.height}});
    var search=newEl('input',{class:['multiselect-dropdown-search'].concat([config.searchInput?.class??'form-control']),style:{width:'100%',display:el.attributes['multiselect-search']?.value==='true'?'block':'none'},placeholder:config.txtSearch});
    listWrap.appendChild(search);
    div.appendChild(listWrap);
    listWrap.appendChild(list);

    el.loadOptions=()=>{
      list.innerHTML='';

      if(el.attributes['multiselect-select-all']?.value=='true'){
        var op=newEl('div',{class:'multiselect-dropdown-all-selector'})
        var ic=newEl('input',{type:'checkbox'});
        op.appendChild(ic);
        op.appendChild(newEl('label',{text:config.txtAll}));

        op.addEventListener('click',()=>{
          op.classList.toggle('checked');
          op.querySelector("input").checked=!op.querySelector("input").checked;

          var ch=op.querySelector("input").checked;
          list.querySelectorAll(":scope > div:not(.multiselect-dropdown-all-selector)")
            .forEach(i=>{if(i.style.display!=='none'){i.querySelector("input").checked=ch; i.optEl.selected=ch}});

          el.dispatchEvent(new Event('change'));
        });
        ic.addEventListener('click',(ev)=>{
          ic.checked=!ic.checked;
        });
        el.addEventListener('change', (ev)=>{
          let itms=Array.from(list.querySelectorAll(":scope > div:not(.multiselect-dropdown-all-selector)")).filter(e=>e.style.display!=='none')
          let existsNotSelected=itms.find(i=>!i.querySelector("input").checked);
          if(ic.checked && existsNotSelected) ic.checked=false;
          else if(ic.checked==false && existsNotSelected===undefined) ic.checked=true;
        });

        list.appendChild(op);
      }

      Array.from(el.options).map(o=>{
        var op=newEl('div',{class:o.selected?'checked':'',optEl:o})
        var ic=newEl('input',{type:'checkbox',checked:o.selected});
        op.appendChild(ic);
        op.appendChild(newEl('label',{text:o.text}));

        op.addEventListener('click',()=>{
          op.classList.toggle('checked');
          op.querySelector("input").checked=!op.querySelector("input").checked;
          op.optEl.selected=!!!op.optEl.selected;
          el.dispatchEvent(new Event('change'));
        });
        ic.addEventListener('click',(ev)=>{
          ic.checked=!ic.checked;
        });
        o.listitemEl=op;
        list.appendChild(op);
      });
      div.listEl=listWrap;

      div.refresh=()=>{
        div.querySelectorAll('span.optext, span.placeholder').forEach(t=>div.removeChild(t));
        var sels=Array.from(el.selectedOptions);
        if(sels.length>(el.attributes['multiselect-max-items']?.value??5)){
          div.appendChild(newEl('span',{class:['optext','maxselected'],text:sels.length+' '+config.txtSelected}));
        }
        else{
          sels.map(x=>{
            var c=newEl('span',{class:'optext',text:x.text, srcOption: x});
            if((el.attributes['multiselect-hide-x']?.value !== 'true'))
              c.appendChild(newEl('span',{class:'optdel',text:'🗙',title:config.txtRemove, onclick:(ev)=>{c.srcOption.listitemEl.dispatchEvent(new Event('click'));div.refresh();ev.stopPropagation();}}));

            div.appendChild(c);
          });
        }
        if(0==el.selectedOptions.length) div.appendChild(newEl('span',{class:'placeholder',text:el.attributes['placeholder']?.value??config.placeholder}));
      };
      div.refresh();
    }
    el.loadOptions();

    search.addEventListener('input',()=>{
      list.querySelectorAll(":scope div:not(.multiselect-dropdown-all-selector)").forEach(d=>{
        var txt=d.querySelector("label").innerText.toUpperCase();
        d.style.display=txt.includes(search.value.toUpperCase())?'block':'none';
      });
    });

    div.addEventListener('click',()=>{
      div.listEl.style.display='block';
      search.focus();
      search.select();
    });

    document.addEventListener('click', function(event) {
      if (!div.contains(event.target)) {
        listWrap.style.display='none';
        div.refresh();
      }
    });
  });
}

window.addEventListener('load',()=>{
  MultiselectDropdown(window.MultiselectDropdownOptions);
});
</script>

</html>
