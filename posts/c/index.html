<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>The problem with C | cor3ntin</title>


<link rel="stylesheet" href="/css/style.css"/><link rel='stylesheet' href='https://cor3ntin.github.io/custom.css'></head>
<body>

<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://cor3ntin.github.io"><h1 class="title is-4">cor3ntin</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/cor3ntin' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/cor3ntin' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="rss" href='' target='_blank' rel='noopener'>
            <span class="icon">
                <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
    
  </svg>
</i>
            </span>
          </a>
        </nav>
      </div>
    </nav>

    
  </div>
</section>

<section class="section">
  <article class="container" id="article">
    <div class="subtitle is-6 is-pulled-right">
      
    </div>
    <h2 class="subtitle is-6">August 30, 2020</h2>
    <h1 class="title">The problem with C</h1>
    
    <div class="content">
      <p><img src="fight.jpeg" alt="Fish"></p>
<p>In the early 70s, C was created at Bell Labs as a byproduct of the development of UNIX.
It quickly became one of the most popular programming languages.
But it was not expressive enough for Bjarne Stroustrup.
And so, in 1983, as a byproduct of his Ph.D. thesis, he extended C.</p>
<p>C with classes was born.</p>
<p>At the time, Bjarne Stroustrup understood that a programming language has many components,
not only the language, its compiler, but also a linker and libraries.
Offering a familiar tool also makes adoption easier.
In this historical context, it makes sense that C++ would be based on C.</p>
<p>Fast-forward 40 years later.</p>
<p>Both C and C++ are widely used in the industry.
But go 5 minutes on the Internet and C developers will tell you that C++ is the most horrific man-made creation,
while many C++ developers wait for the day when C finally burns in the hot flames of hell.</p>
<h2 id="so-what-happened">So what happened?</h2>
<p>On the surface, C and C++ cater to the same use cases: high performance, deterministic, native but portable code for the widest range of hardware and applications.</p>
<p>But C is proudly a low-level language. A nicer assembly.</p>
<p>From day one, C++ had magic. Dark witchcraft: destructors. Suddenly the compiler was doing things on its own.
It also had type inference very early on, but the developers of the mid-80s were not quite ready for that and Bjarne Stroustrup
was pressured into removing <code>auto</code>, until it was added back to C++11.</p>
<p>From then, C++ got more and more tools to build abstractions.
I don&rsquo;t think it would be fair to say that C++ is a low-level or high-level language. It&rsquo;s both, by design.
But building high-level abstractions while not sacrificing performance is hard.
C++ then needed tools to achieve that: <code>constexpr</code>, move semantics, templates, and an ever-growing standard library.</p>
<p>Fundamentally I think C trusts developers while C++ trusts compilers.
This is a massive difference that sharing the same native types or syntax for while loop cannot hide.</p>
<p>C++ developers blame C for all their lost limbs, while C developers probably think C++ is batshit crazy.
I imagine that is a fair perspective if you look at C++ through a C lense. C++ is pretty wild <em>as a superset of C</em>.
A seasoned C person looking at C++ expecting familiarity in C++ will not find it. C++ is not C.
This is enough to feed flamewars for generations.</p>
<p>But as much as I dislike C, I don&rsquo;t have any legitimacy to make fun of it. See, I have some experience with C++ but I
wrote very little C. It was probably bad C.
A language is also its good practices, patterns, idioms, and these take years to learn. If you try to write C code like it&rsquo;s C++ or C++ like it is C, you will have a bad time.
Knowing <a href="https://www.youtube.com/watch?v=YnWhqhNdYyk">C doesn&rsquo;t teach you C++</a>. Knowing C++ does not teach you C.</p>
<p>So can we all stop saying C/C++, regret the unfortunate naming, and sing kumbaya in harmony?
Not so fast.</p>
<p>See, despite being philosophically different from C, C++ is still somewhat a superset of C.
That is to say, you can include a C header in a C++ translation unit and that should compile.
And this is where it gets messy.</p>
<p>C++ is not an extension of C.
It is designed as a separate standard, by a different committee, different people.
Logically, people who like C++'s philosophy will get involved in the C++ community and the C++ standardization process
while other people might try to get involved with C.
Committees, whether its C&rsquo;s or C++'s, only manifest intent and direction through their respective end-product: the standards; standards which are the fruits of numerous voting.</p>
<p>At the same time, it is difficult for a compiler to know that it is dealing with a C header or a C++ header.</p>
<p><code>extern &quot;C&quot;</code> is not used consistently and only affects mangling, but neither grammar nor semantics.
And headers only exists in the eyes of the preprocessor, for a C++ compiler, everything is a C++ translation unit, and therefore C++.
And yet, people include C headers in C++ and expect it to &ldquo;just work&rdquo; ™️.
Which it mostly does.</p>
<p>We can wonder then,</p>
<h2 id="how-c-maintains-c-compatibility-while-being-developed-by-different-people-in-different-places">How C++ maintains C compatibility while being developed by different people in different places?</h2>
<p>Badly, I&rsquo;m afraid.</p>
<p>A coworker recently reminded me of Conway&rsquo;s law:</p>
<blockquote>
<p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&rsquo;s communication structure</p>
</blockquote>
<p>By that logic, it would stand to reason that if the two committees don&rsquo;t interoperate,
neither would the languages they produce.</p>
<p>C++ maintains a list of <a href="http://eel.is/c++draft/diff.iso">incompatibilities with C</a> and <a href="http://eel.is/c++draft/diff.library">its stadard library</a>.
This list does not seem to reflect the many features that were added to C11 and C18 but are not valid C++ constructs. <a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">Wikipedia</a> draws a clearer picture.</p>
<p>Listing incompatibilities isn&rsquo;t sufficient to get a measure of incompatibilities between both languages.</p>
<p>Functions that exist in the C++ standard library but whose primary declaration is expected to come from C are difficult to make <code>constexpr</code>, and more difficult still to make <code>noexcept</code>.
C compatibility translates to performance costs and C functions are optimization barriers.</p>
<p>Many C constructs are valid C++ but should never pass a code review (<code>NULL</code>, <code>longjmp</code>, <code>malloc</code>, create/destroy functions, VLA, <code>free</code>, C  casts), etc.</p>
<p>These might not be bad C idioms, but they are bad C++. C++ has a stronger type system,
and unfortunately using C idioms punch a giant hole in that type system, and so C compatibility has a cost in terms of safety.</p>
<p>Don&rsquo;t get me wrong, C++ still care about C compatibility. Somewhat.
And interestingly C cares about C++. Somewhat.
Truth be told, C might care about C++ more than C++ cares about C.
So each committee cares somewhat about what the other does.
We care reluctantly.</p>
<p>See, C++ is aware of the many foundational libraries written in C, not only the <code>libc</code> but also <code>zip</code>, <code>png</code>, <code>curl</code>, <code>openssl</code> (!), and countless others, which are used in many, many C++ projects.
We can&rsquo;t break that.</p>
<p>But recently, especially over the past decade, C++ has become much bigger than C.
C++ has more users - and a much more active community: <a href="https://nullprogram.com/blog/2018/11/21/">There Are No C Conferences</a>.
Maybe that&rsquo;s why the C++ committee is now over 10 times the size of the C committee.</p>
<p>C++ then is a force to be reckoned with and the C committee has to consider not breaking C++.
To the point that if a standard would track another, these days, C++ leads and C follow.</p>
<p>C++ is now on a steady three years cycle come rain or shine, or deadly pandemics.
Meanwhile, C has a major release every decade or so.
This makes sense. As a lower-level language, C doesn&rsquo;t need to evolve as fast.</p>
<p>The C landscape is also rather different from the C++ landscape.
C caters to more platforms and a lot more compilers.
Everybody and their dog is writing C compilers because the language has a surface area small enough to make that possible, whereas the C++ committee will only really consider 4 implementations, all of which are represented at every meeting.
As a result, many features in C are implementation-defined or optionally supported so that the variety of compilers that exist can claim conformance without doing much work, which I&rsquo;m told pleases regulatory bodies.</p>
<p>C++ these days is more interested in portability than implementation freedom. Yet another difference of philosophy.</p>
<h2 id="so-your-proposal-breaks-c-compatibility">So, your proposal breaks C compatibility</h2>
<p>Parts of my <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2178r1.pdf">P2178</a> paper theoretically affects C compatibility.
In such cases, none of the options seems satisfactory.</p>
<p>You could be told that you have to first get your feature into C. Which means more meetings.
Meetings you might not be able to attend because C has strict <a href="https://thephd.github.io/follow-the-river-wg14-ithaca-2019">attendance rules</a> - Excluding individuals not willing to put down thousands of dollars to become ISO members.
This is because the C committee is forced to adhere strictly to ISO rules.</p>
<p>It might also take a decade if the standard just shipped.
And most importantly, it might go nowhere if the C committee doesn&rsquo;t understand or doesn&rsquo;t care about the particular problem you are trying to solve.
And they probably don&rsquo;t have the bandwidth to deal with it.
And you may not have the bandwidth to deal with C. After all, you joined C++ to improve C++.
In fact, if the room invites you to &ldquo;talk to the C committee&rdquo;, it is likely your proposal is dead, even in the unlikely event that no one in the room was against it.</p>
<p>Another likely scenario is that the C committee accepts a version of a proposal that is slightly different from what exists in C++.
<code>true</code>? Let&rsquo;s make that a macro. <code>char16_t</code> ? Let&rsquo;s make that a typedef. <code>char32_t</code>? Not necessarily UTF-32. <code>static_assert</code> ? <code>_Static_assert</code>.</p>
<p>The list goes on. Should we blame C? Probably not. Their committee does what they think is best for their language.
The opposite is true too. In C++20 designated initializers were inspired by C&rsquo;s but are slightly different because they would otherwise not fit with the C++ initialization rules.</p>
<p>I am part of the problem. C has VLAs. I would vote against a proposal to adopt that in standard C++, <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Kills-The-VLA">too many security issues</a>. A proposal to add <code>_Generic</code> to C++ would be over-my-dead-body. I am not sure if <code>_Generic</code> attempts to palliate to the lack of template or the lack of overloads, but C++ has both these features - from my point of view <code>_Generic</code> doesn&rsquo;t fit into the big picture of what I imagine C++ to be.</p>
<p>Both committees seem also inconsistent in how much they care about the other language.
Sometimes we go to great lenghts (<a href="https://en.cppreference.com/w/cpp/numeric/complex">std::complex</a>), sometimes we don&rsquo;t care at all (<a href="https://en.cppreference.com/w/c/language/array">static array parameters</a>).</p>
<p>There is no way around this. Don&rsquo;t forget that each committee is a bunch of people
voting at different times in different rooms and trying to control the outcome would defeat the purpose
of having a room.
Putting people in the same room is not realistic either. ISO might object and the participation inbalance
would put C people at an enormous disadvantage.</p>
<h2 id="c-compatibility-doesnt-matter-kinda">C compatibility doesn&rsquo;t matter, kinda</h2>
<p>If you are a C developer, I imagine you see C as a neat programming language.
But for the rest of us, C is something else.</p>
<p>C is the universal, cross-language glue that ties it all together.</p>
<p>For C++ users, C is exactly its API.
And with that in mind, the value of C is in its simplicity.
Remember that the subset of C that C++ cares about is the subset that appears in interfaces, in header files. We care about declarations. Not definitions.
C++ wants to call functions in C libraries (or Python, Fortran, Rust, D, Java, etc, in all cases C can be used at the interface boundary).</p>
<p>In that light, <strong>C is an interface definition language</strong>. The more bells and whistles are added to C, the harder it gets to define interfaces. And the less likely it is that these interfaces will remain stable over time.</p>
<p>So does it matter that <code>&lt;threads.h&gt;</code> is missing in C++?
Probably not, because that&rsquo;s unlikely to appear in public interfaces.</p>
<h2 id="everybody-talks-c-these-days">Everybody talks C these days</h2>
<p>In the days of yore, C compatibility was a big selling point for C++.
Nowadays however, everyone and their goldfish understand C.
Rust can call C functions. Python. Java. Everything!
Even freaking Javascript can call C functions in WebAssemby.</p>
<p>But in these languages the interface is explicit.
The language offers tools to expose specific C declarations.
Sure, it is more cumbersome.
But it makes the interface very very clear. And bounded.
In rust, for example, calling a C function doesn&rsquo;t force Rust
to sacrifice some of its design to accommodate a C subset.
No, C is contained.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">mod</span> <span style="color:#b06;font-weight:bold">confinment</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">use</span><span style="color:#bbb"> </span>std::os::raw::{c_char};<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">extern</span><span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#34;C&#34;</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">puts</span>(txt: *<span style="color:#080;font-weight:bold">const</span><span style="color:#bbb"> </span>c_char);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">unsafe</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span>confinment::puts(<span style="color:#bbb">
</span><span style="color:#bbb">            </span>std::ffi::CString::new(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, world!&#34;</span>).expect(<span style="color:#d20;background-color:#fff0f0">&#34;failed!&#34;</span>).as_ptr()<span style="color:#bbb">
</span><span style="color:#bbb">        </span>);<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><p><a href="https://godbolt.org/z/YP66Tf">Compiler Explorer</a></p>
<p>This code will works util the C <em>ABI</em> changes. And the Rust/C boundary is self-documenting and clearly visible.</p>
<p>And so C++ may be the language that pays its C compatibility the most.</p>
<p>And worse, open any C header, you will soon find a bunch of <code>#ifdef __cplusplus</code>.
That&rsquo;s right, C++ compatibility often requires C developers a lot of work.
Compatibility was a mirage all this time. I am remembered of this tweet:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Pet peeve: code chock full of <a href="https://twitter.com/hashtag/ifdefs?src=hash&amp;ref_src=twsrc%5Etfw">#ifdefs</a> is _not_ &quot;portable code&quot;. It is, at best, code that&#39;s been ported a lot. There&#39;s a big difference.</p>&mdash; Fabian Giesen (@rygorous) <a href="https://twitter.com/rygorous/status/1224413742667988992?ref_src=twsrc%5Etfw">February 3, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="where-do-we-go-from-there">Where do we go from there?</h2>
<p>I think both committees are trying to talk more. There is even a planned joined meeting next year in Portland (although plans might change. Pandemic. Portland&hellip;).
Communication is good.</p>
<p>But cats and dogs can only do so much communication.
The design pillars of either language might not be reconciliable.
I will burn on the stake for suggesting a template. But not before complaining loudly about C having no module nor namespace system and WHAT THE HELL IS THAT MACRO.</p>
<p>Maybe it&rsquo;s okay to restrict (!) the subset of C that C++ accepts to C99?
Maybe both languages need to find a common subset (<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2522.pdf">not this one</a>) and evolve independently?
Maybe <code>extern C</code> needs to affect parsing. If C++ had epochs, C could be an epoch.</p>
<p>Maybe we need to embrace C as a subset of C++, but the only way to
do that is to dissolve WG14 into WG21.</p>
<p>It is possible that the status quo doesn&rsquo;t change. C++ might never free itself from its origins (core dumped), while C is condemned to never breath lest they sink the ungodly pile of features that dared take on its name.</p>

      
    <div id="socialshareDiv">
        <h1>Share on </h1>
        <span class="icon-share-span"><a href="http://www.reddit.com/submit?url=https%3a%2f%2fcor3ntin.github.io%2fposts%2fc%2f" target="_blank" title="Submit to Reddit"><i class="icon-share icon-share-reddit"><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M2.204 14.049c-.06.276-.091.56-.091.847 0 3.443 4.402 6.249 9.814 6.249 5.41 0 9.812-2.804 9.812-6.249 0-.274-.029-.546-.082-.809l-.015-.032c-.021-.055-.029-.11-.029-.165-.302-1.175-1.117-2.241-2.296-3.103-.045-.016-.088-.039-.126-.07-.026-.02-.045-.042-.067-.064-1.792-1.234-4.356-2.008-7.196-2.008-2.815 0-5.354.759-7.146 1.971-.014.018-.029.033-.049.049-.039.033-.084.06-.13.075-1.206.862-2.042 1.937-2.354 3.123 0 .058-.014.114-.037.171l-.008.015zm9.773 5.441c-1.794 0-3.057-.389-3.863-1.197-.173-.174-.173-.457 0-.632.176-.165.46-.165.635 0 .63.629 1.685.943 3.228.943 1.542 0 2.591-.3 3.219-.929.165-.164.45-.164.629 0 .165.18.165.465 0 .645-.809.808-2.065 1.198-3.862 1.198l.014-.028zm-3.606-7.573c-.914 0-1.677.765-1.677 1.677 0 .91.763 1.65 1.677 1.65s1.651-.74 1.651-1.65c0-.912-.739-1.677-1.651-1.677zm7.233 0c-.914 0-1.678.765-1.678 1.677 0 .91.764 1.65 1.678 1.65s1.651-.74 1.651-1.65c0-.912-.739-1.677-1.651-1.677zm4.548-1.595c1.037.833 1.8 1.821 2.189 2.904.45-.336.719-.864.719-1.449 0-1.002-.815-1.816-1.818-1.816-.399 0-.778.129-1.09.363v-.002zM2.711 9.963c-1.003 0-1.817.816-1.817 1.818 0 .543.239 1.048.644 1.389.401-1.079 1.172-2.053 2.213-2.876-.302-.21-.663-.329-1.039-.329v-.002zm9.217 12.079c-5.906 0-10.709-3.205-10.709-7.142 0-.275.023-.544.068-.809C.494 13.598 0 12.729 0 11.777c0-1.496 1.227-2.713 2.725-2.713.674 0 1.303.246 1.797.682 1.856-1.191 4.357-1.941 7.112-1.992l1.812-5.524.404.095s.016 0 .016.002l4.223.993c.344-.798 1.138-1.36 2.065-1.36 1.229 0 2.231 1.004 2.231 2.234 0 1.232-1.003 2.234-2.231 2.234s-2.23-1.004-2.23-2.23l-3.851-.912-1.467 4.477c2.65.105 5.047.854 6.844 2.021.494-.464 1.144-.719 1.833-.719 1.498 0 2.718 1.213 2.718 2.711 0 .987-.54 1.886-1.378 2.365.029.255.059.494.059.749-.015 3.938-4.806 7.143-10.72 7.143l-.034.009zm8.179-19.187c-.74 0-1.34.599-1.34 1.338 0 .738.6 1.34 1.34 1.34.732 0 1.33-.6 1.33-1.334 0-.733-.598-1.332-1.347-1.332l.017-.012z"/>
    
  </svg>
</i></a></span>
        <span class="icon-share-span"><a href="https://twitter.com/intent/tweet?source=https%3a%2f%2fcor3ntin.github.io%2fposts%2fc%2f&via=cor3ntin" target="_blank" title="Tweet"><i class="icon-share icon-share-twitter"><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg>
</i></a></span>
        <span class="icon-share-span"><a href="https://news.ycombinator.com/submit?u=https%3a%2f%2fcor3ntin.github.io%2fposts%2fc%2f&t=The%20problem%20with%20C" target="_blank" title="Submit to Hacker News"><i class="icon-share icon-share-hn"><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2'>
    
    <path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/>
    
  </svg>
</i></a></span>
      </div>
    </div>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'cor3ntin';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119011218-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  showMathMenu: false,
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
<script>
  (function addHeadingLinks(){
    var article = document.getElementById('article');
    if(!article)
        return;
    var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(function(heading){
      if(heading.id){
        var a = document.createElement('a');
        a.innerHTML = heading.innerHTML;
        a.href = '#'+heading.id;
        heading.innerHTML = '';
        heading.appendChild(a);
      }
    });
  })();
</script>
<script>
(function () {
    let compilers = {
        "gcc-trunk" : {"compiler" : "gsnapshot", "options" : "-O3 -std=c++2a"},
        "default" : {"compiler" : "g81", "options" : ""},
        "gcc-concepts" : {"compiler" : "g81", "options" : "-O1 -fconcepts -std=c++2a"},
        "autonsdmi"    : {"compiler" : "clang_autonsdmi", "options" : "-O3 -std=c++2a -Wall"},
        "executors"    : {"compiler" : "clang_concepts", "options" :  "-O3 -std=c++2a -Xclang -fconcepts-ts -stdlib=libc++ -pthread"},
        "meta"         : {"lang": "cppx", "compiler" : "cppx_trunk", "options": "-O3 -std=c++2a"}
    }
    const ce_nodes = document.querySelectorAll('.compiler_explorer_block');
    for (let i = 0, len = ce_nodes.length; i < len; i++) {
        let element  = ce_nodes[i];
        let settings = compilers[element.getAttribute("compiler")] || compilers["default"]
        let codeBlock = element.querySelector(".highlight code :not([hidden])");
        let source = unescape(element.textContent).trim();
        let content = [];
        let compiler = "g81";
        let options =
        content.push({
            type: 'component',
            componentName: 'codeEditor',
            componentState: {
                id: 1,
                source: source,
                options: {compileOnChange: true, colouriseAsm: true},
                fontScale: 1,
                lang: settings["lang"] || "c++"
            }
        });
        content.push({
            type: 'component',
            componentName: 'compiler',
            componentState: {
                source: 1,
                filters: {commentOnly: true, directives: true, intel: true, labels: true, trim: true, libraryCode: true},
                options : settings["options"],
                compiler: settings["compiler"],
                fontScale: 0.8,
                libs: [{"name":"boost", "ver" :"171"}, {"name":"cmcstl2", "ver" :"trunk"},{"name" : "gsl", "ver":"100"}, {"name":"rangesv3", "ver" :"trunk"}]


            }
        });
        let obj = {
            version: 4,
            content: [{type: 'row', content: content}]
        };
        let ceFragment = encodeURIComponent(JSON.stringify(obj));
        let parent = element.parentElement;
        const baseUrl = 'https://gcc.godbolt.org/';
        let a = document.createElement('a');
        a.setAttribute('href', baseUrl + "#" + ceFragment);
        a.setAttribute('target', '_blank');
        a.setAttribute('class', 'compiler-explorer-view-button');
        a.setAttribute('title', "Test on Compiler Explorer !");

        let img = document.createElement('img');
        img.setAttribute('src', '/compiler_explorer.svg');
        img.setAttribute('alt', 'Test on Compiler Explorer !');
        img.setAttribute('class', 'compiler-explorer-view-button-img');
        a.appendChild(img);
        codeBlock.appendChild(a);
    }
})();
</script>
</html>

